:numbered:
:title: Gabriel PDI
:author: Luís Gabriel P. Condados
:email: gabriellgpc@hotmail.com
:sourcedir: U1/
:data-uri:
:icons: font
:experimental:
:stem:
:toc: left
:doctype: book
:source-highlighter: pygments
:caution-caption: Cuidado
:important-caption: Importante
:note-caption: Nota
:tip-caption: Dica
:warning-caption: Aviso
:appendix-caption: Appêndice
:example-caption: Exemplo
:figure-caption: Figura
:listing-caption: Listagem
:table-caption: Tabela
:toc-title: Sumário
:preface-title: Prefácio
:version-label: Versão
:last-update-label: Última atualização

= Processamento Digital de Imagens

Programas/atividades desenvolvidas para a disciplina https://www.dca.ufrn.br/~ambj/dca0445-programa.html[DCA0445 -
Processamento Digital de Imagens], do curso de Engenharia de Computação
da *Universidade Federal do Rio grande do Norte* https://www.ufrn.br/[UFRN]

= Prefácio
Todos os programas, neste documento, foram desenvolvidas em `*C++*` utilizando-se da biblioteca https://opencv.org/[*_OpenCV_*]
e em ambiente _Linux_. Para compilar qualquer programa presente neste documento, pode-se fazer uso deste link:Makefile[Makefile], coloca o Makefile na mesma pasta do
código fonte, extensão .cpp, e execute via terminal o comando
`make <nome_do_programa>`. Todos os códigos encontram-se no https://github.com/Gabriellgpc/Processamento_de_Imagem[Repositório do github].


== Programa Region

Este programa consiste em negativar uma certa região dentro de uma imagem, delimitada por um retângulo informado
pelo usuário. o programa varre a área correspondente na imagem e troca os valores dos pixels para seus inversos, ou seja
255 - valor_atual.

Compilando e Executando.
....
$ make region
$ ./region <caminho_para_a_imagem>
....

O código fonte completo se encontra aqui link:U1/region.cpp[region.cpp].

[source,cpp]
----
void region(Mat &img, CvPoint *p){
  for(unsigned int i = p[0].x; i < p[1].x; i++)
    for(unsigned int j = p[0].y; j < p[1].y; j++)
      img.at<uint8_t>(i,j) = 255 - img.at<uint8_t>(i,j);
}
----

[.float-group]
--
[.left.text-center]
image::U1/imagens/toto_mini.png[title="Entrada do programa Region"]

[.left.text-center]
image::U1/resultados/region_result.png[title="Saída do programa Region"]
--

== Troca Regiões

O usuário deve passar uma imagem qualquer, e o programa passara para escala de cinza e particionara a
imagem em 4(quatro) partes simétricas e realizara a troca na diagonal dessas quatro subimagens.

Para este programa uma imagem foi pensada sendo composta por 4 regiões da seguinte forma:

[cols="e,m", width="25%"]
|===
| A | B
| C | D
|===


Compilando e Executando.
....
$ make trocaregioes
$ ./trocaregioes <caminho_para_a_imagem>
....

Código completo em link:U1/trocaregioes.cpp[trocaregioes.cpp]
//link para baixar codigo fonte

[source,cpp]
----
{
  w = img.size().width;
  h = img.size().height;
  result = img.clone();

  img(cv::Rect(0,0, w/2, h/2)).copyTo(result(cv::Rect((w-1)/2, (h-1)/2, w/2, h/2)));  ;;<1>
  img(cv::Rect((w-1)/2, 0, w/2, h/2)).copyTo(result(cv::Rect(0, (h-1)/2, w/2, h/2))); ;;<2>
  img(cv::Rect(0, (h-1)/2, w/2, h/2)).copyTo(result(cv::Rect((w-1)/2, 0, w/2, h/2))); ;;<3>
  img(cv::Rect((w-1)/2, (h-1)/2, w/2, h/2)).copyTo(result(cv::Rect(0, 0, w/2, h/2))); ;;<4>
}
----
<1> Sobrepoe A da img original em D de result
<2> Sobrepoe B da img original em C de result
<3> Sobrepoe C da img original em B de result
<4> Sobrepoe D da img original em A de result

Resultado
[cols="e,m", width="25%"]
|===
| D | C
| B | A
|===

// Imagens de antes e depois
[.float-group]
--
[.left.text-center]
image::U1/imagens/toto_mini.png[title="Entrada do programa trocaregioes"]

[.left.text-center]
image::U1/resultados/trocaRegiao_resultado.png[title="Saída do programa trocaregioes"]
--


== Conta Bolhas

Este programa consiste em contar o número de regiões brancas puras, com e sem "buracos", o fundo da imagem deve ser
puramente preto e os objetos puramente brancos, o programa foi testado utilizando a imagem link:U1/imagens/bolhas.png[bolhas.png].
Mas o mesmo deve funcionar para qualquer imagem que siga o padrão especificado a cima.

image::U1/imagens/bolhas.png[title="Bolhas.png"]

O algoritmo consiste em 4 passos bem definidos. O código completo se encontra neste link: link:U1/contaregioes.cpp[contaregioes.cpp].

=== Passo 1- Remover objetos das bordas
[source,cpp]
----
//remove da borda superior e inferior
for(int i = 0; i < width; i++){
  if(image.at<uint8_t>(0, i) == OBJ_COLOR)
    floodFill(image, CvPoint(i, 0), BACK_COLOR);
  if(image.at<uint8_t>(height-1,i) == OBJ_COLOR)
    floodFill(image, CvPoint(i, height-1), BACK_COLOR);
}

//remove das laterais
for(int i = 0; i < height; i++){
  //lateral esquerda
  if(image.at<uint8_t>(i, 0) == OBJ_COLOR)
    floodFill(image, CvPoint(0, i), BACK_COLOR);
  //lateral direita
  if(image.at<uint8_t>(i, width-1) == OBJ_COLOR)
    floodFill(image, CvPoint(width-1, i), BACK_COLOR);
}
----

=== Passo 2- Contar bolhas com buraco

[source,cpp]
----
//troca o background, para facilitar a identificar os buracos das bolhas
floodFill(image, CvPoint(0,0), NEW_BACK_COLOR);
for(int i = 0; i < height; i++)
  for(int j = 0; j < width; j++)
  {
    //identifica uma bolha com buraco
    if(image.at<uint8_t>(i,j) == BACK_COLOR && image.at<uint8_t>(i,j-1) == OBJ_COLOR){
      //soma um no numero de bolhas e "apaga" a bolha encontrada
      nbolhas_com_buracos++;
      floodFill(image, CvPoint(j-1, i), NEW_BACK_COLOR);
    }
  }
----

=== Passo 3- Contar bolhas sem buracos

[source,cpp]
----
//conta bolhas sem buracos
for(int i = 0; i < height; i++)
  for(int j = 0; j < width; j++)
  {
    //identifica uma bola
    if(image.at<uint8_t>(i,j) == OBJ_COLOR){
      //soma um no numero de bolhas e "apaga" a bolha encontrada
      nbolhas_sem_buracos++;
      floodFill(image, CvPoint(j, i), NEW_BACK_COLOR);
    }
  }
----

=== Resultado

image::U1/resultados/conta_bolhas_resultado.png[title="Resultado da contagem."]

== Histograma

=== Equalize

Implementação de um Equalizador de Histograma para imagens em tons de cinza.

Algoritmo de equalização (imagens em tons de cinza) utilizado:

. Calcular Histograma: latexmath:[h(r_k), k \in [0,255]];
. Calcular Histograma Acumulado: latexmath:[ha(r_k) = \sum{h(r_j)}, j \in [0,255]];
. Normalizar o Histograma Acumulado, na faixa de [0, 255]: latexmath:[ha(r_k) = ha(r_k)/ha(r_255)];
. Transformar a imagem: latexmath:[f(x,y) = ha(f(x,y))].

[source, cpp]
----
include::U1/equalize.cpp[]
----

Antes e Depois da equalização do histograma.
[.float-group]
--
[.left.text-center]
image::U1/resultados/equalize_input.png[title="Entrada do programa equalize"]

[.left.text-center]
image::U1/resultados/equalize_output.png[title="Resultado do programa equalize"]
--
Código completo: link:U1/equalize.cpp[equalize.cpp]

=== Motiondetector

Utilizando comparação de histogramas entre frames consecutivos, comparando-o por calculo da
correlação(usando função do _OpenCV_, link:https://docs.opencv.org/2.4.13.7/doc/tutorials/imgproc/histograms/histogram_comparison/histogram_comparison.html[compareHist]),
para identificar ocorrência de movimento, para isso foi estabelecido, de forma empírica, um limiar para a correlação, ao se identificar um valor de correlação abaixo
do limiar, um circulo verde é desenhado no canto superior direito da imagem, indicando uma detecção de movimento.

link:U1/Makefile[Makefile] utilizado para compilar o programa motiondetector, é diferente pois inclui
a capacidade de gerar gifs.

image::U1/Motiondetector.gif[title="Resultado do Motiondetector."]

[source, cpp]
----
include::U1/motiondetector.cpp[]
----

Download do código fonte: link:U1/motiondetector.cpp[Motiondetector.cpp].

== Filtros 2D

=== Laplaciano do Gaussiano (Lapgauss)

image::U1/resultados/Filter2D.gif[title="Resultado do lapgauss.cpp"]

código completo: link:U1/lapgauss.cpp[lapgauss.cpp]

[source, cpp]
----
include::U1/lapgauss.cpp[]
----

=== Tilt-Shift

video::tlqX-Gxkr20[youtube, 640, 480, title="Demonstração Tiltshift"]

Código completo: link:U1/tiltshift.cpp[tiltshift.cpp].

[source, cpp]
----
include::U1/tiltshift.cpp[]
----

=== Tilt-Shift em Vídeo

Vídeo original: https://pixabay.com/pt/videos/carros-auto-estrada-velocidade-1900/[]

video::Aczqpso7W_8[youtube, 640, 480, title="Demonstração Tiltshift em vídeo"]

Código completo em: link:U1/tiltshift_video.cpp[tiltshift_video.cpp].

[source, cpp]
----
include::U1/tiltshift_video.cpp[]
----

== Filtro Homomórfico
Falta implementar...


== Bibliografia
[bibliography]
- Rafael Gonzalez. 'Processamento Digital de Imagens'. Addison-Wesley. 1990. 2 ed.
